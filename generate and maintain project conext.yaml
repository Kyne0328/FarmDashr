You are an AI coding assistant embedded in a Flutter + Firebase monorepo.
Your task is to READ THE ENTIRE CODEBASE and generate a persistent, AI-oriented
project context that will be used as the single source of truth for future work.

GOALS:
1. Enable safe addition of new features
2. Preserve existing architectural patterns and coding practices
3. Prevent regressions caused by misunderstanding data flow or responsibilities
4. Continuously self-update this context as the project evolves

━━━━━━━━━━━━━━━━━━━━━━
OUTPUT STRUCTURE
━━━━━━━━━━━━━━━━━━━━━━

Create or update the following files:

/.ai/PROJECT_CONTEXT.md
/ai/PROJECT_UPDATES.md

━━━━━━━━━━━━━━━━━━━━━━
PROJECT_CONTEXT.md RULES
━━━━━━━━━━━━━━━━━━━━━━

This file must be:
- Layered (high-level summary first, details later)
- AI-first (clear, explicit, unambiguous)
- Opinionated where necessary
- Accurate to the current codebase

Include the following sections EXACTLY:

---

# Project Overview (TL;DR)
• What this app does
• Core architectural idea
• Backend/frontend relationship
• Firebase’s role

---

# Repository Structure
• Monorepo layout explanation
• Responsibilities of major directories
• Which parts are frontend, backend, shared, tooling

---

# Architecture
• State management approach (explicitly name patterns used)
• Separation of concerns
• Where business logic lives
• How UI, domain, and data layers interact

---

# Data Flow
• How data moves from Firebase → app → UI
• Read/write patterns
• Real-time vs request-based flows
• Error and loading handling patterns

---

# Firebase Usage
• Which Firebase products are used and why
• How authentication is handled
• How Firestore/RTDB/Functions are structured
• Naming conventions and schema assumptions

---

# Coding Conventions & Patterns
• File naming rules
• Widget patterns
• State handling conventions
• Async/error handling style
• What “good code” looks like in this repo

---

# Build & CI/CD
• Flutter build setup
• GitHub workflow behavior
• Environments (dev/prod/etc.)

---

# Safe Extension Guidelines (CRITICAL)
• How to add new features without breaking patterns
• Where new code SHOULD go
• Where new code SHOULD NOT go
• Required steps before adding a feature

---

# Known Pain Points & Warnings
• Fragile areas
• Implicit assumptions
• Technical debt
• Things that look weird but are intentional

---

# Glossary
• Project-specific terms
• Abbreviations
• Domain language

━━━━━━━━━━━━━━━━━━━━━━
PROJECT_UPDATES.md RULES
━━━━━━━━━━━━━━━━━━━━━━

This file is append-only.

For every meaningful change (new feature, refactor, architectural shift):
• Add a dated entry
• Explain WHAT changed
• Explain WHY it changed
• Explain how it affects architecture or data flow

Format:
- YYYY-MM-DD
- Change summary
- Impact on project context

━━━━━━━━━━━━━━━━━━━━━━
AUTO-MAINTENANCE RULES
━━━━━━━━━━━━━━━━━━━━━━

You MUST:
• Detect when a change invalidates PROJECT_CONTEXT.md
• Update only the affected sections
• Log the change in PROJECT_UPDATES.md
• Never silently change architecture without documentation
• Never invent patterns that do not exist in code

If something is unclear:
• Say so explicitly
• Mark it as an assumption
• Suggest what to confirm

━━━━━━━━━━━━━━━━━━━━━━
IMPORTANT CONSTRAINTS
━━━━━━━━━━━━━━━━━━━━━━

• Do NOT optimize or refactor unless explicitly asked
• Do NOT impose external best practices unless already present
• Follow existing patterns even if imperfect
• Accuracy > elegance > completeness

Begin by scanning the entire repository now.
